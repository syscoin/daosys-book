# Tokenomics

The tokenomics model representing the minimum commit- ment of verified child DAOs is illustrated in five steps in Fig. 4. This model represents a symbiotic relationship between DAOSYS and its respective child DAOs. This is where verified child DAOs receives the interest generated from its own collateral and DAOSYS receives debt-based interest generated from that collateral.

Included in this symbiotic relationship are several other benefits that child DAOs will have by joining this network over building its own standalone DAO. New DAOs benefit from significantly fast development time by selecting any one of the pre-vetted, secure DAOSYS templates. Included in this, DAOs can simulate the tokenomic behavior prior to launch using our Python simulator tailored to our system (as detailed in Section V-C) to build predictive models to deter- mine future estimated ROI calculations. DAOs that are part of our network will also benefit from the seamless integrations of working with other participating DAOs. These integrations would be akin to the benefits nation states have when they join international trade agreements, where DAOSYS behaves as the overseeing regulatory body, and the child DAOs share attributes as participating nation states. These child DAOs also have the flexibility of cloning the DAOSYS factory and spawning its own sub-network within the DAOSYS ecosystem; see Fig. 5.

### Tokenomics Model

The five steps of the tokenomics model described in Fig. 4 are as follows. In step A we initially assume DAOSYS vaults contains no assets, while the child DAO vaults have 1000 SYS and 200 DAI. In step B we have a triggering event that stimulates a small deposit of 1 SYS and 0.2 DAI from the Child DAO vaults into the DAOSYS vaults. When this happens the DAOSYS vault will mint debt tokens of these newly acquired assets with a 1:1 backing. In exchange for these assets, the child DAO will receive newly minted index tokens that represent a 1:1 backing by DAOSYS. Next in step C, DAOSYS will send both these debt and collateral tokens through a DeFi investment engine. Over time, the DAOSYS vault will collect interest from these newly acquired collateral and debt assets, as seen in step D. The child DAO can either keep these collateral in DAOSYS and continue to collect interest or recall the collateral. Hence, finally in step E of this process, the child DAO recalls the original collateral and all its earned interest, while DAOSYS keeps the debt interest. Once the child DAOs collateral and interest is withdrawn, both dept and index tokens are burned. When comparing the final step to the initial step, we see that both DAOSYS and the child DAO see a net positive gain in liquidity. The child DAO will collect interest from its own collateral, while DAOSYS will collect interest from the debt created from that collateral.

<figure><img src="../.gitbook/assets/tokenomics_model.png" alt=""><figcaption><p>FIGURE 4: Tokenomics model representing minimum com- mitment of publicly and privately verified child DAOs</p></figcaption></figure>

### Clone Model

When considering the outline of Section V-A, we can see emergent behaviour that will arise for DAOs that are also clones of DAOSYS as illustrated in Fig. 5. When considering the tokenomics model in Section V-A, there will arise a bidirectional cascade effect where DAOSYS will receive the cascaded interest accumulated on debt, and the the child DAOs will receive the cascaded interest accumulated on collateral.

<figure><img src="../.gitbook/assets/clone_model.png" alt=""><figcaption><p>FIGURE 5: Clone model that emerges from the tokenomics model of Fig. 4 which occurs as a byproduct from child DAOs creating their own children; collateral interest gener- ated by DAOSYS cascades up through inheritance structure to all respective verified child DAOs, while debt interest cascades down to DAOSYS</p></figcaption></figure>

### DeFi Python Simulator

To realize proper tokenomics design, it is highly inefficient to invest resources into development without first conducting a proper simulations of the design to test specifications for various outcomes. This is what every DeFi project in the crypto space is not doing. This is why we are introducing an open source python package to simulate various sandboxed DeFi components of DAOSYS so that project engineers, managers and designers can pre-plan outcomes prior to in- vesting valuable resources into development.

With this tool, DAOSYS designers can utilize the plug and play components of our simulator to build tokenomics mockups for business planning purposes so that teams can come together and get collective consensus alongside potential users and investors. Not only is this tool applicable to DAOSYS, it can be used as a general purpose tool to simulate DEX activity for anyone wishing to setup their own liquidity pool (LP) and wish to stress test their ideas prior to development. This can be used as a powerful design tool to explore the limitations of an DeFi project idea prior to committing valuable resources on development costs (ie, Devs and Project Managers). Table 1 and Fig. 6 highlight the main components of the simulator, so that potential users of the system can get a higher level understanding of the DeFi simulator package.

<figure><img src="../.gitbook/assets/simulator (1).png" alt=""><figcaption><p>FIGURE 6: System components to DeFi Python simulator for DAOSYS</p></figcaption></figure>

We have a working beta version of the simulator which is available through Syscoin’s Github repository. This simulator is being built alongside DAOSYS, and we are using this to understand the ROI and design considerations for DAOSYS’s first usecase (ie, Masternode Yield Farming). Since the simulator is still in the beta stage, the setup is currently not realized to its full intention. However, a downloadable demo of this tool is available from Syscoin’s Github repository for the community to begin using. For a mini python tutorial on how to use this tool, please refer to \[8] and refer to \[9] for a series of example Jupyter notebooks.

The purpose of this tool is primarily for the design aspect of DAOSYS, and is still in its early stages of development. The next stages involve feeding the output of various mathematical models into the simulator framework and to use this tool to simulate other DeFi usecases. This is so that we can test a roster of edge cases to build more robust systems. The final goal is to bring this system to a level of maturity so that it can be utilized in parallel with the contracts in real time. Hence, exposing DeFi to a scientific way of design, testing, and implementation.

| Simulator Component | Description                                                                                                                                                                                            |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Agents**          | Entities that engage with the system, and are subcategorized into tokens and users                                                                                                                     |
| **Events**          | Agnostic events that take place within the system (eg, mint, deposit, withdraw, swap, and rebase)                                                                                                      |
| **ModelQueue**      | Queue of univariate events that are modelled aprior that can be fed into the system as events                                                                                                          |
| **Actions**         | Event actions that are fed into the system performed by agents; they can either be single stand-alone independent event actions or chained together with dependency                                    |
| **ActionChains**    | Actions that have dependencies on other actions as inputs                                                                                                                                              |
| **ActionBatch**     | Batches of actions placed together into a repeatable sequence; there is only one assigned time delta per the pass of each batch, and there is no limit as to the number of batches that can be created |
| **Liquidity Pools** | Pool of two token agents managed by constant product trading                                                                                                                                           |
| **Orchestrator**    | Manages agents and actions working within the system                                                                                                                                                   |
| **Event Queue**     | Queue of storable actions                                                                                                                                                                              |
| **Event Executor**  | Final step which executes queue of action events                                                                                                                                                       |
